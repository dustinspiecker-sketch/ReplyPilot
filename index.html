<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ReplyPilot ‚Äì Review Replies lokal ‚Ä¢ 3D</title>
  <meta name="description" content="Komplett lokale, ein‚ÄëDatei 3D‚ÄëLandingpage ohne CDNs: Berg/Glacier‚ÄëAnalogien, Sterne‚ÄëKrone, Guardrail‚ÄëShield, Parallax, Scroll‚ÄëReveal.">
  <style>
    :root{
      --bg:#0b0d12; --bg-2:#0f1320; --txt:#e8ecf1; --muted:#aab3c2;
      --brand:#8cf7e2; --brand-2:#7aa9ff; --stroke:rgba(255,255,255,.12);
      --glass:rgba(255,255,255,.06); --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    html{scroll-behavior:smooth}
    body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; color:var(--txt);
      background: radial-gradient(1200px 800px at 70% -20%, #142034 0%, var(--bg) 60%), linear-gradient(180deg, var(--bg-2), var(--bg)); overflow-x:hidden}
    a{color:inherit; text-decoration:none}
    .container{width:min(1200px,88vw); margin-inline:auto}
    .nav{position:fixed; inset-inline:0; top:0; z-index:50; backdrop-filter:saturate(120%) blur(8px); background:linear-gradient(180deg, rgba(20,24,34,.75), rgba(20,24,34,.25) 60%, rgba(20,24,34,0)); border-bottom:1px solid var(--stroke)}
    .nav-inner{display:flex; align-items:center; justify-content:space-between; padding:14px 20px}
    .logo{display:flex; align-items:center; gap:12px; font-weight:700; letter-spacing:.2px}
    .logo-dot{width:14px; height:14px; border-radius:50%; background:radial-gradient(circle at 30% 30%, var(--brand), #4cd3ff 60%, #1b8fd9 100%); box-shadow:0 0 24px #4cd3ff80}
    .btn{position:relative; display:inline-flex; align-items:center; gap:10px; padding:12px 16px; border-radius:14px; border:1px solid var(--stroke); background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)); color:var(--txt); box-shadow:var(--shadow); transition:transform .2s ease}
    .btn:hover{transform:translateY(-1px)}
    .btn-primary{background:linear-gradient(120deg, var(--brand), var(--brand-2)); color:#0a0e16; border-color:transparent; font-weight:700}
    .btn-ghost{background:transparent}

    .hero{position:relative; min-height:100vh; display:grid; place-items:center; padding-top:80px}
    #stage{position:absolute; inset:0; display:block}
    .webgl-fallback{position:absolute; inset:0; display:none; place-items:center; color:#c6d0e0}
    .no-webgl .webgl-fallback{display:grid}
    .hero-glow{position:absolute; inset:0; pointer-events:none; z-index:1; background:radial-gradient(600px 400px at var(--x,50%) var(--y,40%), #3be3ff22, transparent 60%), radial-gradient(800px 600px at 20% 100%, #8cf7e218, transparent 70%)}
    .hero-inner{position:relative; z-index:2; padding:10vh 0 12vh}
    .eyebrow{display:inline-flex; align-items:center; gap:10px; font-size:.9rem; color:var(--muted); letter-spacing:.3px; background:rgba(255,255,255,.06); border:1px solid var(--stroke); padding:8px 12px; border-radius:999px}
    .badge-dot{width:8px; height:8px; border-radius:50%; background:linear-gradient(180deg, var(--brand), var(--brand-2))}
    .headline{font-size: clamp(2.4rem, 6vw, 5rem); line-height:1.02; letter-spacing:-.02em; margin:18px 0; font-weight:800}
    .gradient-text{background:linear-gradient(100deg, #fff, var(--brand) 45%, var(--brand-2)); -webkit-background-clip:text; background-clip:text; color:transparent}
    .sub{color:var(--muted); font-size: clamp(1rem, 2vw, 1.2rem); max-width:60ch}
    .cta-row{margin-top:28px; display:flex; gap:12px; flex-wrap:wrap}
    .metrics{margin-top:34px; display:flex; gap:18px; flex-wrap:wrap; color:var(--muted)}
    .metrics b{color:var(--txt)}

    section{padding:96px 0}
    .section-title{font-size: clamp(1.6rem, 3.2vw, 2.2rem); margin:0 0 16px; font-weight:800}
    .section-sub{color:var(--muted); max-width:70ch}

    .grid{display:grid; gap:18px}
    .features{grid-template-columns:repeat(12, 1fr); margin-top:32px}
    .card{grid-column:span 4; border:1px solid var(--stroke); background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)); padding:22px; border-radius:18px; min-height:170px}
    .card .icon{width:28px; height:28px; border-radius:8px; display:grid; place-items:center; background:linear-gradient(120deg, var(--brand), var(--brand-2)); color:#0c1220; font-weight:900; box-shadow:0 10px 20px #7aa9ff33}
    .card h3{margin:14px 0 8px; font-size:1.05rem}
    .card p{color:var(--muted)}

    .how{grid-template-columns:repeat(12, 1fr); gap:20px; margin-top:28px}
    .step{grid-column:span 6; border:1px dashed var(--stroke); border-radius:18px; padding:22px; display:flex; gap:16px; align-items:flex-start}
    .step .no{width:32px; height:32px; border-radius:10px; background:var(--glass); display:grid; place-items:center; color:var(--brand)}

    .pricing{grid-template-columns:repeat(12, 1fr); gap:20px; margin-top:36px}
    .tier{grid-column:span 6; border:1px solid var(--stroke); border-radius:22px; padding:26px; background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02))}
    .price{font-size:2.0rem; font-weight:800}
    .tier ul{margin:12px 0 0; padding:0 0 0 18px; color:var(--muted)}

    footer{padding:60px 0; border-top:1px solid var(--stroke); color:var(--muted)}

    @media (max-width: 980px){ .card{grid-column:span 6} .step{grid-column:span 12} .tier{grid-column:span 12} }
    @media (max-width: 640px){ .card{grid-column:span 12} }

    [data-reveal]{opacity:0; transform:translateY(16px); transition:opacity .6s ease, transform .6s ease}
    .revealed{opacity:1 !important; transform:none !important}

    /* Optional Debug-Overlay */
    #dbg{position:fixed; right:8px; bottom:8px; background:rgba(0,0,0,.5); color:#cfe7ff; font:12px/1.4 monospace; padding:8px 10px; border:1px solid #2b4769; border-radius:8px; display:none; z-index:9999}
  </style>
</head>
<body>
  <nav class="nav" aria-label="Hauptnavigation">
    <div class="container nav-inner">
      <a href="#" class="logo" aria-label="Startseite">
        <span class="logo-dot" aria-hidden="true"></span>
        <span>Reply<span style="color:var(--brand)">Pilot</span></span>
      </a>
      <div class="nav-cta">
        <a class="btn btn-ghost" href="#features">Features</a>
        <a class="btn btn-ghost" href="#how">Ablauf</a>
        <a class="btn btn-primary" href="#pricing">Kostenlos testen</a>
      </div>
    </div>
  </nav>

  <header class="hero" id="top">
    <canvas id="stage" aria-hidden="true"></canvas>
    <div class="webgl-fallback"><div>Dein Browser unterst√ºtzt WebGL nicht ‚Äì du siehst eine statische Version.</div></div>
    <div class="hero-glow" id="heroGlow" aria-hidden="true"></div>
    <div class="container hero-inner">
      <span class="eyebrow"><span class="badge-dot"></span> KI‚ÄëAntworten auf Bewertungen ‚Äì on‚Äëbrand & in Minuten</span>
      <h1 class="headline">Mehr Sterne. Mehr Vertrauen. <span class="gradient-text">Weniger Aufwand.</span></h1>
      <p class="sub">Automatisiere Antworten auf Google‚ÄëBewertungen mit Freigabe‚ÄëButton: positiv auto, schwierig mit Eskalation. 100¬†% markenkonform, 0¬†% Copy‚ÄëPaste‚ÄëStress.</p>
      <div class="cta-row">
        <a class="btn btn-primary" href="#pricing">Jetzt kostenlos testen</a>
        <a class="btn" href="#features">So funktioniert‚Äôs</a>
      </div>
      <div class="metrics">
        <span><b>‚â§ 24 h</b> Antwortzeit</span>
        <span>‚Ä¢</span>
        <span><b>60‚Äì70 %</b> Auto‚ÄëPost</span>
        <span>‚Ä¢</span>
        <span><b>1‚ÄëKlick</b> Freigabe bei Negativf√§llen</span>
      </div>
    </div>
  </header>

  <section id="features">
    <div class="container">
      <h2 class="section-title" data-reveal>Warum ReplyPilot?</h2>
      <p class="section-sub" data-reveal>Lokale Sichtbarkeit und Vertrauen wachsen mit schnellen, hilfreichen Antworten. Unser System liefert Entw√ºrfe in deiner Tonalit√§t ‚Äì du entscheidest mit einem Klick.</p>
      <div class="grid features">
        <article class="card" data-reveal>
          <div class="icon">‚ö°</div>
          <h3>Sofort startklar</h3>
          <p>E‚ÄëMail‚ÄëTrigger & Telegram‚ÄëButtons gen√ºgen. Keine komplexe Einrichtung ‚Äì los geht‚Äôs am selben Tag.</p>
        </article>
        <article class="card" data-reveal>
          <div class="icon">üéØ</div>
          <h3>Markenkonform</h3>
          <p>Wissensbasis mit 5‚Äì10 Richtlinien (Tonalit√§t, Kulanz, Kontaktweg). Keine Interna in √∂ffentlichen Antworten.</p>
        </article>
        <article class="card" data-reveal>
          <div class="icon">üõ°Ô∏è</div>
          <h3>Guardrails</h3>
          <p>Heikle Themen werden automatisch an dich eskaliert. Positive 5‚ÄëSterne: nach Delay vollautomatisch.</p>
        </article>
      </div>
    </div>
  </section>

  <section id="how">
    <div class="container">
      <h2 class="section-title" data-reveal>So funktioniert‚Äôs</h2>
      <p class="section-sub" data-reveal>Von der neuen Bewertung bis zur Antwort ‚Äì in Minuten statt Stunden.</p>
      <div class="grid how">
        <div class="step" data-reveal>
          <div class="no">1</div>
          <div><h3>Erkennen</h3><p>Neue Review trifft ein (E‚ÄëMail/API). Bot klassifiziert Sentiment & Thema.</p></div>
        </div>
        <div class="step" data-reveal>
          <div class="no">2</div>
          <div><h3>Entwurf</h3><p>Antwortvorschlag in deiner Tonalit√§t, mit {Filiale}, {Hotline}, {√ñffnungszeiten} aus der Wissensbasis.</p></div>
        </div>
        <div class="step" data-reveal>
          <div class="no">3</div>
          <div><h3>Freigabe</h3><p>Telegram/Slack‚ÄëButtons: <b>Approve</b> / <b>Edit</b> / <b>Escalate</b>. Positive 5‚òÖ auf Wunsch auto.</p></div>
        </div>
        <div class="step" data-reveal>
          <div class="no">4</div>
          <div><h3>Posten & Report</h3><p>Antwort wird ver√∂ffentlicht. Monatlicher Report: Antwortrate, Zeit bis Antwort, Top‚ÄëThemen.</p></div>
        </div>
      </div>
    </div>
  </section>

  <section id="pricing">
    <div class="container">
      <h2 class="section-title" data-reveal>Preise</h2>
      <p class="section-sub" data-reveal>Einfach starten, monatlich k√ºndbar. Sp√§ter jederzeit upgraden.</p>
      <div class="grid pricing">
        <div class="tier" data-reveal>
          <h3>Starter</h3>
          <div class="price">99¬†‚Ç¨ <span style="font-size:.9rem; color:var(--muted)">/Monat</span></div>
          <ul>
            <li>Bis 30 Antworten/Monat</li>
            <li>Positiv: Auto‚ÄëPost (Delay)</li>
            <li>Negativ: 1‚ÄëKlick‚ÄëFreigabe</li>
            <li>E‚ÄëMail‚ÄëReport</li>
          </ul>
          <div style="margin-top:18px"><a class="btn btn-primary" href="#top">Kostenlos testen</a></div>
        </div>
        <div class="tier" data-reveal>
          <h3>Pro</h3>
          <div class="price">199¬†‚Ç¨ <span style="font-size:.9rem; color:var(--muted)">/Monat</span></div>
          <ul>
            <li>Bis 100 Antworten/Monat</li>
            <li>API‚ÄëPosting & Eskalationen</li>
            <li>Custom‚ÄëTonalit√§t & Policies</li>
            <li>Monatsreport (HTML/PDF)</li>
          </ul>
          <div style="margin-top:18px"><a class="btn btn" href="#top">Demo anfragen</a></div>
        </div>
      </div>
    </div>
  </section>

  <footer>
    <div class="container" style="display:flex; justify-content:space-between; gap:16px; flex-wrap:wrap">
      <div>¬© <span id="year"></span> ReplyPilot</div>
      <div style="display:flex; gap:16px">
        <a href="#">Impressum</a>
        <a href="#">Datenschutz</a>
      </div>
    </div>
  </footer>

  <div id="dbg"></div>

<script>
// ======================= PURE WEBGL (ohne Libraries) =======================
(function(){
  const canvas = document.getElementById('stage');
  const fallback = document.querySelector('.webgl-fallback');
  const heroGlow = document.getElementById('heroGlow');
  const gl = canvas.getContext('webgl', {antialias:true, alpha:false});
  if(!gl){ document.body.classList.add('no-webgl'); fallback.style.display='grid'; return; }

  // --- globals BEFORE resize()
  let dpr = 1;

  // --- utils
  function createShader(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); } return s; }
  function createProgram(vs, fs){ const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(p)); } return p; }
  function mat4(){ return new Float32Array(16); }
  function mat4Identity(out){ out.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); return out; }
  function mat4Perspective(out, fovy, aspect, near, far){ const f=1/Math.tan(fovy/2), nf=1/(near-far); out.set([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]); return out; }
  function mat4LookAt(out, eye, center, up){ let x0,x1,x2,y0,y1,y2,z0,z1,z2,len; z0=eye[0]-center[0]; z1=eye[1]-center[1]; z2=eye[2]-center[2]; len=Math.hypot(z0,z1,z2); if(len===0){z2=1;} else {z0/=len; z1/=len; z2/=len;} x0=up[1]*z2-up[2]*z1; x1=up[2]*z0-up[0]*z2; x2=up[0]*z1-up[1]*z0; len=Math.hypot(x0,x1,x2); if(len!==0){x0/=len; x1/=len; x2/=len;} y0=z1*x2-z2*x1; y1=z2*x0-z0*x2; y2=z0*x1-z1*x0; out.set([x0,y0,z0,0, x1,y1,z1,0, x2,y2,z2,0, -(x0*eye[0]+x1*eye[1]+x2*eye[2]), -(y0*eye[0]+y1*eye[1]+y2*eye[2]), -(z0*eye[0]+z1*eye[1]+z2*eye[2]), 1]); return out; }
  function mat4Mul(out,a,b){
    const r=new Float32Array(16);
    for(let c=0;c<4;c++){
      for(let rIdx=0;rIdx<4;rIdx++){
        r[c*4 + rIdx] = a[0*4 + rIdx]*b[c*4 + 0] + a[1*4 + rIdx]*b[c*4 + 1] + a[2*4 + rIdx]*b[c*4 + 2] + a[3*4 + rIdx]*b[c*4 + 3];
      }
    }
    out.set(r); return out;
  }

  // ===== Mountain (Vertex) + Ice/Rock (Fragment) =====
  const planeVS = `
    precision mediump float; attribute vec3 aPos; attribute vec2 aUv;
    varying vec2 vUv; varying float vH; varying vec3 vWorld;
    uniform float uTime; uniform float uAmp; uniform float uFreq; uniform mat4 uPV; uniform mat4 uModel;

    // value-noise + fbm
    float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
    float noise(in vec2 p){
      vec2 i=floor(p); vec2 f=fract(p);
      float a=hash(i);
      float b=hash(i+vec2(1.0,0.0));
      float c=hash(i+vec2(0.0,1.0));
      float d=hash(i+vec2(1.0,1.0));
      vec2 u=f*f*(3.0-2.0*f);
      return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
    }
    float fbm(vec2 p){
      float v=0.0; float a=0.5; mat2 m=mat2(1.6,1.2,-1.2,1.6);
      for(int i=0;i<5;i++){ v+=a*noise(p); p=m*p; a*=0.5; }
      return v;
    }

    void main(){
      vUv = aUv; vec3 p = aPos; float t=uTime*0.25;
      // radial base (cone) + fbm details ‚Üí mountain
      float r = length(p.xy*vec2(0.8,1.0)); // slightly oval
      float base = max(0.0, 1.0 - r);
      float n = fbm(p.xy*0.8 + vec2(0.0, t*0.25)); // subtle time drift
      float h = (base*1.15 + n*0.55*base) * uAmp; // height
      p.z += h; vH = h;
      vec4 world = uModel * vec4(p,1.0);
      vWorld = world.xyz;
      gl_Position = uPV * world;
    }`;

  const planeFS = `
    #extension GL_OES_standard_derivatives : enable
    precision mediump float; varying vec2 vUv; varying float vH; varying vec3 vWorld;
    uniform vec3 uC1; uniform vec3 uC2; uniform float uTime; uniform float uFog; uniform vec3 uCam;

    vec3 fogColor = vec3(0.06, 0.08, 0.12);

    void main(){
      // fake normal from world-space derivatives
      vec3 dx = dFdx(vWorld); vec3 dy = dFdy(vWorld);
      vec3 N = normalize(cross(dx, dy));
      vec3 L = normalize(vec3(0.6, 0.8, 0.2));
      vec3 V = normalize(uCam - vWorld);

      // rock vs ice by height threshold
      float ice = smoothstep(0.35, 0.75, vH); // high = ice
      vec3 rockCol = mix(vec3(0.10,0.14,0.22), vec3(0.12,0.22,0.30), clamp(vH*1.2,0.0,1.0));
      vec3 iceCol  = mix(uC1*0.6 + vec3(0.05,0.08,0.10), uC2*0.9, 0.5 + 0.5*ice);

      // lighting
      float diff = max(dot(N,L), 0.0);
      // subtle specular for ice only
      vec3 H = normalize(L+V);
      float spec = pow(max(dot(N,H),0.0), 64.0) * ice * 0.9;

      vec3 col = mix(rockCol, iceCol, ice);
      col = col * (0.35 + 0.75*diff) + spec * vec3(0.85,1.0,0.95);

      // mint guardrail flash (subtle time pulse added in JS via uniform uFog/scene state)
      // distance fog
      float dist = length(uCam - vWorld);
      float f = 1.0 - exp(-uFog * dist*0.55);
      col = mix(col, fogColor, clamp(f,0.0,1.0));

      gl_FragColor = vec4(col, 0.95);
    }`;

  const planeProgram = createProgram(createShader(gl.VERTEX_SHADER, planeVS), createShader(gl.FRAGMENT_SHADER, planeFS));
  const pLoc = {
    pos:gl.getAttribLocation(planeProgram,'aPos'),
    uv:gl.getAttribLocation(planeProgram,'aUv'),
    uTime:gl.getUniformLocation(planeProgram,'uTime'), uAmp:gl.getUniformLocation(planeProgram,'uAmp'), uFreq:gl.getUniformLocation(planeProgram,'uFreq'),
    uPV:gl.getUniformLocation(planeProgram,'uPV'), uModel:gl.getUniformLocation(planeProgram,'uModel'),
    uC1:gl.getUniformLocation(planeProgram,'uC1'), uC2:gl.getUniformLocation(planeProgram,'uC2'), uFog:gl.getUniformLocation(planeProgram,'uFog'), uCam:gl.getUniformLocation(planeProgram,'uCam')
  };

  // Geometry grid (non-indexed)
  const segBase = (innerWidth<640)? 64:96; const w=6.0, h=3.5; const nx=segBase, ny=segBase;
  const verts=[], uvs=[];
  for(let y=0;y<ny;y++){
    for(let x=0;x<nx;x++){
      const x0 = x/nx - 0.5, x1 = (x+1)/nx - 0.5;
      const y0 = y/ny - 0.5, y1 = (y+1)/ny - 0.5;
      const p00=[x0*w, y0*h, 0], p10=[x1*w, y0*h, 0], p01=[x0*w, y1*h, 0], p11=[x1*w, y1*h, 0];
      const t00=[x0+0.5, y0+0.5], t10=[x1+0.5, y0+0.5], t01=[x0+0.5, y1+0.5], t11=[x1+0.5, y1+0.5];
      verts.push(...p00, ...p10, ...p11, ...p00, ...p11, ...p01);
      uvs.push(...t00, ...t10, ...t11, ...t00, ...t11, ...t01);
    }
  }
  function buf(type, data, usage){ const b = gl.createBuffer(); gl.bindBuffer(type, b); gl.bufferData(type, data, usage||gl.STATIC_DRAW); return b; }
  const planeVBO = buf(gl.ARRAY_BUFFER, new Float32Array(verts));
  const planeUVBO = buf(gl.ARRAY_BUFFER, new Float32Array(uvs));
  const planeCount = verts.length / 3;

  // ===== Crown Points (5 Sterne) + optional Shield =====
  const ptsVS = `
    precision mediump float; attribute vec3 aPos; uniform mat4 uPV; uniform float uSize; void main(){
      gl_Position = uPV * vec4(aPos,1.0); gl_PointSize = uSize; }`;
  const ptsFS = `
    precision mediump float; uniform vec3 uCol; uniform float uPulse; void main(){
      vec2 d = gl_PointCoord - vec2(0.5); float r = length(d);
      float glow = smoothstep(0.5, 0.0, r) * (0.7 + 0.3*uPulse);
      gl_FragColor = vec4(uCol, glow);
    }`;
  const ptsProgram = createProgram(createShader(gl.VERTEX_SHADER, ptsVS), createShader(gl.FRAGMENT_SHADER, ptsFS));
  const ptLoc = { pos:gl.getAttribLocation(ptsProgram,'aPos'), uPV:gl.getUniformLocation(ptsProgram,'uPV'), uSize:gl.getUniformLocation(ptsProgram,'uSize'), uCol:gl.getUniformLocation(ptsProgram,'uCol'), uPulse:gl.getUniformLocation(ptsProgram,'uPulse') };

  // crown positions (world space around peak)
  const CROWN_N=6; // 5 stars + 1 optional shield pulse rendered as point as well
  const cData = new Float32Array(CROWN_N*3);
  function updateCrown(y){
    const R = 0.35, Z = 0.0; // small ring above origin
    for(let i=0;i<5;i++){
      const a = (i/5)*6.28318 + 0.2; // rotate a bit
      cData[i*3+0] = Math.cos(a)*R;
      cData[i*3+1] = y;
      cData[i*3+2] = Math.sin(a)*R + Z;
    }
    // shield point slightly below and in front
    cData[15] = 0.75; cData[16] = y*0.65; cData[17] = 0.6;
  }
  updateCrown(1.1);
  const ptsVBO = buf(gl.ARRAY_BUFFER, cData);

  // --- matrices
  const proj = mat4(), view = mat4(), pv = mat4(), model = mat4(); mat4Identity(model);
  // tilt plane
  (function(){ const a=-Math.PI/2.2, c=Math.cos(a), s=Math.sin(a); model.set([1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1]); })();

  const scene = { cam:[0,0.7,3.6], fog:0.22, crown:1.0, shield:0.0 };
  let target = { cam:[...scene.cam], fog:scene.fog, crown:scene.crown, shield:scene.shield };

  function resize(){
    const hdr = document.querySelector('.hero'); const r = hdr.getBoundingClientRect();
    dpr = Math.min(devicePixelRatio||1, 1.75);
    canvas.width=r.width*dpr; canvas.height=r.height*dpr; canvas.style.width=r.width+'px'; canvas.style.height=r.height+'px';
    gl.viewport(0,0,canvas.width,canvas.height);
    mat4Perspective(proj, Math.PI/3.1, canvas.width/canvas.height, 0.1, 100.0);
  }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // pointer parallax (adds to camera target)
  let parX=0, parY=0; function onPointer(e){ const cx=(e.touches?e.touches[0].clientX:e.clientX)/innerWidth*2-1; const cy=(e.touches?e.touches[0].clientY:e.clientY)/innerHeight*2-1; parX=cx*0.5; parY=cy*0.2; heroGlow.style.setProperty('--x', (e.clientX||e.touches?.[0].clientX||0)+'px'); heroGlow.style.setProperty('--y', (e.clientY||e.touches?.[0].clientY||0)+'px'); }
  addEventListener('mousemove', onPointer, {passive:true}); addEventListener('touchmove', onPointer, {passive:true});

  gl.enable(gl.DEPTH_TEST); gl.clearColor(0.043,0.051,0.071,1);
  let t=0; const baseCam=[...scene.cam];

  function drawMountain(){
    gl.useProgram(planeProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVBO); gl.enableVertexAttribArray(pLoc.pos); gl.vertexAttribPointer(pLoc.pos,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, planeUVBO); gl.enableVertexAttribArray(pLoc.uv); gl.vertexAttribPointer(pLoc.uv,2,gl.FLOAT,false,0,0);
    gl.uniform1f(pLoc.uTime, t);
    gl.uniform1f(pLoc.uAmp, 1.15); // overall mountain height
    gl.uniform1f(pLoc.uFreq, 1.6);
    gl.uniform3f(pLoc.uC1, 0x8c/255, 0xf7/255, 0xe2/255); // mint
    gl.uniform3f(pLoc.uC2, 0x7a/255, 0xa9/255, 0xff/255); // blue
    gl.uniform1f(pLoc.uFog, scene.fog);
    gl.uniform3f(pLoc.uCam, scene.cam[0], scene.cam[1], scene.cam[2]);
    // PV
    mat4LookAt(view, [scene.cam[0]+parX*0.6, scene.cam[1]+parY*0.3, scene.cam[2]], [0,0,0], [0,1,0]);
    mat4Mul(pv, proj, view);
    gl.uniformMatrix4fv(pLoc.uPV,false,pv);
    gl.uniformMatrix4fv(pLoc.uModel,false,model);
    gl.drawArrays(gl.TRIANGLES, 0, planeCount);
  }

  function drawCrown(){
    gl.disable(gl.DEPTH_TEST); gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(ptsProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, ptsVBO); gl.enableVertexAttribArray(ptLoc.pos); gl.vertexAttribPointer(ptLoc.pos,3,gl.FLOAT,false,0,0);
    // PV same as mountain
    gl.uniformMatrix4fv(ptLoc.uPV,false,pv);
    // pulse + sizes
    const pulse = 0.5 + 0.5*Math.sin(t*1.2);
    gl.uniform1f(ptLoc.uPulse, pulse);
    gl.uniform3f(ptLoc.uCol, 0.55, 0.95, 0.89);
    gl.uniform1f(ptLoc.uSize, (10.0 + 6.0*pulse) * dpr);
    gl.drawArrays(gl.POINTS, 0, 5);

    // shield (6th point)
    const shieldPulse = scene.shield * (0.5 + 0.5*Math.sin(t*3.0));
    gl.uniform3f(ptLoc.uCol, 0.55, 0.95, 0.89);
    gl.uniform1f(ptLoc.uSize, (40.0 + 30.0*shieldPulse) * dpr);
    gl.uniform1f(ptLoc.uPulse, 0.8);
    gl.drawArrays(gl.POINTS, 5, 1);

    gl.disable(gl.BLEND); gl.enable(gl.DEPTH_TEST);
  }

  function animate(){
    t += 0.016;
    // ease scene params toward target
    for(let i=0;i<3;i++){ scene.cam[i] += (target.cam[i]-scene.cam[i])*0.05; }
    scene.fog += (target.fog - scene.fog)*0.05;
    scene.crown += (target.crown - scene.crown)*0.08;
    scene.shield += (target.shield - scene.shield)*0.08;

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    drawMountain();
    drawCrown();
    requestAnimationFrame(animate);
  }
  animate();

  // --- diagnostics (hash #debug)
  const dbg = document.getElementById('dbg');
  if(location.hash.includes('debug')){
    dbg.style.display='block';
    const info = gl.getExtension('WEBGL_debug_renderer_info');
    const ren = info? gl.getParameter(info.UNMASKED_RENDERER_WEBGL): 'n/a';
    const ven = info? gl.getParameter(info.UNMASKED_VENDOR_WEBGL): 'n/a';
    setInterval(()=>{ dbg.textContent = `dpr:${dpr.toFixed(2)}
size:${canvas.width}x${canvas.height}
crown:${scene.crown.toFixed(2)} fog:${scene.fog.toFixed(2)}
renderer:${ren}
vendor:${ven}`; }, 300);
  }

  // --- scene states per section
  const states = {
    top:      { cam:[0,0.7,3.6], fog:0.22, crown:1.0, shield:0.0 },
    features: { cam:[0.6,0.9,3.2], fog:0.16, crown:1.0, shield:0.0 },
    how:      { cam:[-0.5,1.0,3.0], fog:0.12, crown:1.05, shield:1.0 },
    pricing:  { cam:[0,1.1,3.9], fog:0.08, crown:1.1, shield:0.0 }
  };
  function setState(id){ if(states[id]){ target = JSON.parse(JSON.stringify(states[id])); } }

  // smooth anchor scroll remains; we also set scene state on click
  const nav = document.querySelector('.nav');
  document.querySelectorAll('a[href^="#"]').forEach(a=>{
    a.addEventListener('click', function(e){
      const id = this.getAttribute('href');
      if(!id || id==='#') return;
      const el = document.querySelector(id);
      if(!el) return;
      e.preventDefault();
      const name = id.replace('#','');
      setState(name);
      const top = el.getBoundingClientRect().top + window.scrollY - (nav?.offsetHeight||72) - 8;
      window.scrollTo({top, behavior:'smooth'});
    });
  });
})();

// ======================= Scroll Reveal (ohne GSAP) =======================
(function(){
  const els = document.querySelectorAll('[data-reveal]');
  if(!('IntersectionObserver' in window)) { els.forEach(el=>el.classList.add('revealed')); return; }
  const io = new IntersectionObserver((entries)=>{
    entries.forEach(e=>{ if(e.isIntersecting){ e.target.classList.add('revealed'); io.unobserve(e.target);} });
  }, {threshold:0.1});
  els.forEach(el=>io.observe(el));
  const y = document.getElementById('year'); if(y){ y.textContent = new Date().getFullYear(); }
})();
</script>
</body>
</html>
