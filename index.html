<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ReplyPilot ‚Äì Review Replies lokal ‚Ä¢ 3D</title>
  <meta name="description" content="Komplett lokale, ein‚ÄëDatei 3D‚ÄëLandingpage ohne CDNs: Berg/Glacier‚ÄëAnalogien, Sterne‚ÄëKrone, Guardrail‚ÄëShield, Aufstiegs‚ÄëRoute, Parallax, Scroll‚ÄëReveal.">
  <style>
    :root{
      --bg:#0b0d12; --bg-2:#0f1320; --txt:#e8ecf1; --muted:#aab3c2;
      --brand:#8cf7e2; --brand-2:#7aa9ff; --stroke:rgba(255,255,255,.12);
      --glass:rgba(255,255,255,.06); --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    html{scroll-behavior:smooth}
    body{margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; color:var(--txt);
      background: radial-gradient(1200px 800px at 70% -20%, #142034 0%, var(--bg) 60%), linear-gradient(180deg, var(--bg-2), var(--bg)); overflow-x:hidden}
    a{color:inherit; text-decoration:none}
    .container{width:min(1200px,88vw); margin-inline:auto}
    .nav{position:fixed; inset-inline:0; top:0; z-index:50; backdrop-filter:saturate(120%) blur(8px); background:linear-gradient(180deg, rgba(20,24,34,.75), rgba(20,24,34,.25) 60%, rgba(20,24,34,0)); border-bottom:1px solid var(--stroke)}
    .nav-inner{display:flex; align-items:center; justify-content:space-between; padding:14px 20px}
    .logo{display:flex; align-items:center; gap:12px; font-weight:700; letter-spacing:.2px}
    .logo-dot{width:14px; height:14px; border-radius:50%; background:radial-gradient(circle at 30% 30%, var(--brand), #4cd3ff 60%, #1b8fd9 100%); box-shadow:0 0 24px #4cd3ff80}
    .btn{position:relative; display:inline-flex; align-items:center; gap:10px; padding:12px 16px; border-radius:14px; border:1px solid var(--stroke); background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)); color:var(--txt); box-shadow:var(--shadow); transition:transform .2s ease}
    .btn:hover{transform:translateY(-1px)}
    .btn-primary{background:linear-gradient(120deg, var(--brand), var(--brand-2)); color:#0a0e16; border-color:transparent; font-weight:700}
    .btn-ghost{background:transparent}

    .hero{position:relative; min-height:100vh; display:grid; place-items:center; padding-top:80px}
    #stage{position:absolute; inset:0; display:block}
    .webgl-fallback{position:absolute; inset:0; display:none; place-items:center; color:#c6d0e0}
    .no-webgl .webgl-fallback{display:grid}
    .hero-glow{position:absolute; inset:0; pointer-events:none; z-index:1; background:radial-gradient(600px 400px at var(--x,50%) var(--y,40%), #3be3ff22, transparent 60%), radial-gradient(800px 600px at 20% 100%, #8cf7e218, transparent 70%)}
    .hero-inner{position:relative; z-index:2; padding:10vh 0 12vh}
    .eyebrow{display:inline-flex; align-items:center; gap:10px; font-size:.9rem; color:var(--muted); letter-spacing:.3px; background:rgba(255,255,255,.06); border:1px solid var(--stroke); padding:8px 12px; border-radius:999px}
    .badge-dot{width:8px; height:8px; border-radius:50%; background:linear-gradient(180deg, var(--brand), var(--brand-2))}
    .headline{font-size: clamp(2.4rem, 6vw, 5rem); line-height:1.02; letter-spacing:-.02em; margin:18px 0; font-weight:800}
    .gradient-text{background:linear-gradient(100deg, #fff, var(--brand) 45%, var(--brand-2)); -webkit-background-clip:text; background-clip:text; color:transparent}
    .sub{color:var(--muted); font-size: clamp(1rem, 2vw, 1.2rem); max-width:60ch}
    .cta-row{margin-top:28px; display:flex; gap:12px; flex-wrap:wrap}
    .metrics{margin-top:34px; display:flex; gap:18px; flex-wrap:wrap; color:var(--muted)}
    .metrics b{color:var(--txt)}

    section{padding:96px 0}
    .section-title{font-size: clamp(1.6rem, 3.2vw, 2.2rem); margin:0 0 16px; font-weight:800}
    .section-sub{color:var(--muted); max-width:70ch}

    .grid{display:grid; gap:18px}
    .features{grid-template-columns:repeat(12, 1fr); margin-top:32px}
    .card{grid-column:span 4; border:1px solid var(--stroke); background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02)); padding:22px; border-radius:18px; min-height:170px}
    .card .icon{width:28px; height:28px; border-radius:8px; display:grid; place-items:center; background:linear-gradient(120deg, var(--brand), var(--brand-2)); color:#0c1220; font-weight:900; box-shadow:0 10px 20px #7aa9ff33}
    .card h3{margin:14px 0 8px; font-size:1.05rem}
    .card p{color:var(--muted)}

    .how{grid-template-columns:repeat(12, 1fr); gap:20px; margin-top:28px}
    .step{grid-column:span 6; border:1px dashed var(--stroke); border-radius:18px; padding:22px; display:flex; gap:16px; align-items:flex-start}
    .step .no{width:32px; height:32px; border-radius:10px; background:var(--glass); display:grid; place-items:center; color:var(--brand)}

    .pricing{grid-template-columns:repeat(12, 1fr); gap:20px; margin-top:36px}
    .tier{grid-column:span 6; border:1px solid var(--stroke); border-radius:22px; padding:26px; background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.02))}
    .price{font-size:2.0rem; font-weight:800}
    .tier ul{margin:12px 0 0; padding:0 0 0 18px; color:var(--muted)}

    footer{padding:60px 0; border-top:1px solid var(--stroke); color:var(--muted)}

    @media (max-width: 980px){ .card{grid-column:span 6} .step{grid-column:span 12} .tier{grid-column:span 12} }
    @media (max-width: 640px){ .card{grid-column:span 12} }

    [data-reveal]{opacity:0; transform:translateY(16px); transition:opacity .6s ease, transform .6s ease}
    .revealed{opacity:1 !important; transform:none !important}

    /* Optional Debug-Overlay */
    #dbg{position:fixed; right:8px; bottom:8px; background:rgba(0,0,0,.5); color:#cfe7ff; font:12px/1.4 monospace; padding:8px 10px; border:1px solid #2b4769; border-radius:8px; display:none; z-index:9999}
  </style>
</head>
<body>
  <nav class="nav" aria-label="Hauptnavigation">
    <div class="container nav-inner">
      <a href="#" class="logo" aria-label="Startseite">
        <span class="logo-dot" aria-hidden="true"></span>
        <span>Reply<span style="color:var(--brand)">Pilot</span></span>
      </a>
      <div class="nav-cta">
        <a class="btn btn-ghost" href="#features">Features</a>
        <a class="btn btn-ghost" href="#how">Ablauf</a>
        <a class="btn btn-primary" href="#pricing">Kostenlos testen</a>
      </div>
    </div>
  </nav>

  <header class="hero" id="top">
    <canvas id="stage" aria-hidden="true"></canvas>
    <div class="webgl-fallback"><div>Dein Browser unterst√ºtzt WebGL nicht ‚Äì du siehst eine statische Version.</div></div>
    <div class="hero-glow" id="heroGlow" aria-hidden="true"></div>
    <div class="container hero-inner">
      <span class="eyebrow"><span class="badge-dot"></span> KI‚ÄëAntworten auf Bewertungen ‚Äì on‚Äëbrand & in Minuten</span>
      <h1 class="headline">Mehr Sterne. Mehr Vertrauen. <span class="gradient-text">Weniger Aufwand.</span></h1>
      <p class="sub">Automatisiere Antworten auf Google‚ÄëBewertungen mit Freigabe‚ÄëButton: positiv auto, schwierig mit Eskalation. 100¬†% markenkonform, 0¬†% Copy‚ÄëPaste‚ÄëStress.</p>
      <div class="cta-row">
        <a class="btn btn-primary" href="#pricing">Jetzt kostenlos testen</a>
        <a class="btn" href="#features">So funktioniert‚Äôs</a>
      </div>
      <div class="metrics">
        <span><b>‚â§ 24 h</b> Antwortzeit</span>
        <span>‚Ä¢</span>
        <span><b>60‚Äì70 %</b> Auto‚ÄëPost</span>
        <span>‚Ä¢</span>
        <span><b>1‚ÄëKlick</b> Freigabe bei Negativf√§llen</span>
      </div>
    </div>
  </header>

  <section id="features">
    <div class="container">
      <h2 class="section-title" data-reveal>Warum ReplyPilot?</h2>
      <p class="section-sub" data-reveal>Lokale Sichtbarkeit und Vertrauen wachsen mit schnellen, hilfreichen Antworten. Unser System liefert Entw√ºrfe in deiner Tonalit√§t ‚Äì du entscheidest mit einem Klick.</p>
      <div class="grid features">
        <article class="card" data-reveal>
          <div class="icon">‚ö°</div>
          <h3>Sofort startklar</h3>
          <p>E‚ÄëMail‚ÄëTrigger & Telegram‚ÄëButtons gen√ºgen. Keine komplexe Einrichtung ‚Äì los geht‚Äôs am selben Tag.</p>
        </article>
        <article class="card" data-reveal>
          <div class="icon">üéØ</div>
          <h3>Markenkonform</h3>
          <p>Wissensbasis mit 5‚Äì10 Richtlinien (Tonalit√§t, Kulanz, Kontaktweg). Keine Interna in √∂ffentlichen Antworten.</p>
        </article>
        <article class="card" data-reveal>
          <div class="icon">üõ°Ô∏è</div>
          <h3>Guardrails</h3>
          <p>Heikle Themen werden automatisch an dich eskaliert. Positive 5‚ÄëSterne: nach Delay vollautomatisch.</p>
        </article>
      </div>
    </div>
  </section>

  <section id="how">
    <div class="container">
      <h2 class="section-title" data-reveal>So funktioniert‚Äôs</h2>
      <p class="section-sub" data-reveal>Von der neuen Bewertung bis zur Antwort ‚Äì in Minuten statt Stunden.</p>
      <div class="grid how">
        <div class="step" data-reveal>
          <div class="no">1</div>
          <div><h3>Erkennen</h3><p>Neue Review trifft ein (E‚ÄëMail/API). Bot klassifiziert Sentiment & Thema.</p></div>
        </div>
        <div class="step" data-reveal>
          <div class="no">2</div>
          <div><h3>Entwurf</h3><p>Antwortvorschlag in deiner Tonalit√§t, mit {Filiale}, {Hotline}, {√ñffnungszeiten} aus der Wissensbasis.</p></div>
        </div>
        <div class="step" data-reveal>
          <div class="no">3</div>
          <div><h3>Freigabe</h3><p>Telegram/Slack‚ÄëButtons: <b>Approve</b> / <b>Edit</b> / <b>Escalate</b>. Positive 5‚òÖ auf Wunsch auto.</p></div>
        </div>
        <div class="step" data-reveal>
          <div class="no">4</div>
          <div><h3>Posten & Report</h3><p>Antwort wird ver√∂ffentlicht. Monatlicher Report: Antwortrate, Zeit bis Antwort, Top‚ÄëThemen.</p></div>
        </div>
      </div>
    </div>
  </section>

  <section id="pricing">
    <div class="container">
      <h2 class="section-title" data-reveal>Preise</h2>
      <p class="section-sub" data-reveal>Einfach starten, monatlich k√ºndbar. Sp√§ter jederzeit upgraden.</p>
      <div class="grid pricing">
        <div class="tier" data-reveal>
          <h3>Starter</h3>
          <div class="price">99¬†‚Ç¨ <span style="font-size:.9rem; color:var(--muted)">/Monat</span></div>
          <ul>
            <li>Bis 30 Antworten/Monat</li>
            <li>Positiv: Auto‚ÄëPost (Delay)</li>
            <li>Negativ: 1‚ÄëKlick‚ÄëFreigabe</li>
            <li>E‚ÄëMail‚ÄëReport</li>
          </ul>
          <div style="margin-top:18px"><a class="btn btn-primary" href="#top">Kostenlos testen</a></div>
        </div>
        <div class="tier" data-reveal>
          <h3>Pro</h3>
          <div class="price">199¬†‚Ç¨ <span style="font-size:.9rem; color:var(--muted)">/Monat</span></div>
          <ul>
            <li>Bis 100 Antworten/Monat</li>
            <li>API‚ÄëPosting & Eskalationen</li>
            <li>Custom‚ÄëTonalit√§t & Policies</li>
            <li>Monatsreport (HTML/PDF)</li>
          </ul>
          <div style="margin-top:18px"><a class="btn btn" href="#top">Demo anfragen</a></div>
        </div>
      </div>
    </div>
  </section>

  <footer>
    <div class="container" style="display:flex; justify-content:space-between; gap:16px; flex-wrap:wrap">
      <div>¬© <span id="year"></span> ReplyPilot</div>
      <div style="display:flex; gap:16px">
        <a href="#">Impressum</a>
        <a href="#">Datenschutz</a>
      </div>
    </div>
  </footer>

  <div id="dbg"></div>

<script>
// ======================= PURE WEBGL (ohne Libraries) =======================
(function(){
  const canvas = document.getElementById('stage');
  const fallback = document.querySelector('.webgl-fallback');
  const heroGlow = document.getElementById('heroGlow');
  const gl = canvas.getContext('webgl', {antialias:true, alpha:false});
  if(!gl){ document.body.classList.add('no-webgl'); fallback.style.display='grid'; return; }

  // --- globals BEFORE resize()
  let dpr = 1;

  // --- utils
  function createShader(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); } return s; }
  function createProgram(vs, fs){ const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(p)); } return p; }
  function mat4(){ return new Float32Array(16); }
  function mat4Identity(out){ out.set([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); return out; }
  function mat4Perspective(out, fovy, aspect, near, far){ const f=1/Math.tan(fovy/2), nf=1/(near-far); out.set([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0]); return out; }
  function mat4LookAt(out, eye, center, up){ let x0,x1,x2,y0,y1,y2,z0,z1,z2,len; z0=eye[0]-center[0]; z1=eye[1]-center[1]; z2=eye[2]-center[2]; len=Math.hypot(z0,z1,z2); if(len===0){z2=1;} else {z0/=len; z1/=len; z2/=len;} x0=up[1]*z2-up[2]*z1; x1=up[2]*z0-up[0]*z2; x2=up[0]*z1-up[1]*z0; len=Math.hypot(x0,x1,x2); if(len!==0){x0/=len; x1/=len; x2/=len;} y0=z1*x2-z2*x1; y1=z2*x0-z0*x2; y2=z0*x1-z1*x0; out.set([x0,y0,z0,0, x1,y1,z1,0, x2,y2,z2,0, -(x0*eye[0]+x1*eye[1]+x2*eye[2]), -(y0*eye[0]+y1*eye[1]+y2*eye[2]), -(z0*eye[0]+z1*eye[1]+z2*eye[2]), 1]); return out; }
  function mat4Mul(out,a,b){
    const r=new Float32Array(16);
    for(let c=0;c<4;c++){
      for(let rIdx=0;rIdx<4;rIdx++){
        r[c*4 + rIdx] = a[0*4 + rIdx]*b[c*4 + 0] + a[1*4 + rIdx]*b[c*4 + 1] + a[2*4 + rIdx]*b[c*4 + 2] + a[3*4 + rIdx]*b[c*4 + 3];
      }
    }
    out.set(r); return out;
  }

  // ===== Mountain (Vertex) + Ice/Rock (Fragment) =====
  const planeVS = `
    precision mediump float; attribute vec3 aPos; attribute vec2 aUv;
    varying vec2 vUv; varying float vH; varying vec3 vWorld; varying vec3 vN; varying vec2 vXY;
    uniform float uTime; uniform float uAmp; uniform float uFreq; uniform mat4 uPV; uniform mat4 uModel;

    float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
    float noise(in vec2 p){ vec2 i=floor(p); vec2 f=fract(p); float a=hash(i); float b=hash(i+vec2(1.0,0.0)); float c=hash(i+vec2(0.0,1.0)); float d=hash(i+vec2(1.0,1.0)); vec2 u=f*f*(3.0-2.0*f); return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; }
    float fbm(vec2 p){ float v=0.0; float a=0.5; mat2 m=mat2(1.6,1.2,-1.2,1.6); for(int i=0;i<6;i++){ v+=a*noise(p); p=m*p; a*=0.5; } return v; }
    float ridged(vec2 p){ float v=0.0; float a=0.5; mat2 m=mat2(1.7,1.1,-1.1,1.7); for(int i=0;i<5;i++){ float n=1.0-abs(2.0*noise(p)-1.0); v+=n*a; p=m*p; a*=0.5; } return v; }

    float terrace(float x, float steps, float sharp){ float s=x*steps; float f=floor(s); float frac=s-f; float t=pow(frac, sharp); return (f+t)/steps; }

    float heightAt(vec2 xy, float t){
      // domain warp for realistic foldings
      vec2 q = xy*1.0; vec2 warp = vec2(fbm(q*1.8), fbm(q*1.8+vec2(2.3,1.7))) - 0.5; xy += warp*0.35;
      float r = length(xy*vec2(0.8,1.0));
      float base = max(0.0, 1.0 - r);
      float n1 = fbm(xy*0.9 + vec2(0.0, t*0.18));
      float n2 = ridged(xy*1.25 + vec2(0.2, -t*0.15));
      float h = (base*1.25 + (0.55*n1 + 0.60*n2)*base);
      // subtle terracing near top
      h = mix(h, terrace(h, 6.0, 1.6), 0.35);
      return h * uAmp;
    }

    void main(){
      vUv = aUv; vXY = aPos.xy; vec3 p = aPos; float t=uTime*0.25;
      float h = heightAt(p.xy, t);
      p.z += h; vH = h / uAmp; // normalized for masks

      float eps = 0.012;
      float hx = heightAt(p.xy + vec2(eps,0.0), t);
      float hy = heightAt(p.xy + vec2(0.0,eps), t);
      vec3 dx = vec3(eps, 0.0, hx - h);
      vec3 dy = vec3(0.0, eps, hy - h);
      vec3 N = normalize(cross(dx, dy));

      vec4 world = uModel * vec4(p,1.0);
      vWorld = world.xyz;
      vN = normalize(mat3(uModel) * N);
      gl_Position = uPV * world;
    }`;

  const planeFS = `
    precision mediump float; varying vec2 vUv; varying float vH; varying vec3 vWorld; varying vec3 vN; varying vec2 vXY;
    uniform vec3 uC1; uniform vec3 uC2; uniform float uTime; uniform float uFog; uniform vec3 uCam; uniform vec3 uLight; uniform float uAmp;

    // duplicate noise stack for soft shadow sampling
    float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
    float noise(in vec2 p){ vec2 i=floor(p); vec2 f=fract(p); float a=hash(i); float b=hash(i+vec2(1.0,0.0)); float c=hash(i+vec2(0.0,1.0)); float d=hash(i+vec2(1.0,1.0)); vec2 u=f*f*(3.0-2.0*f); return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; }
    float fbm(vec2 p){ float v=0.0; float a=0.5; mat2 m=mat2(1.6,1.2,-1.2,1.6); for(int i=0;i<6;i++){ v+=a*noise(p); p=m*p; a*=0.5; } return v; }
    float ridged(vec2 p){ float v=0.0; float a=0.5; mat2 m=mat2(1.7,1.1,-1.1,1.7); for(int i=0;i<5;i++){ float n=1.0-abs(2.0*noise(p)-1.0); v+=n*a; p=m*p; a*=0.5; } return v; }
    float terrace(float x, float steps, float sharp){ float s=x*steps; float f=floor(s); float frac=s-f; float t=pow(frac, sharp); return (f+t)/steps; }

    float heightAt(vec2 xy, float t){
      vec2 q = xy*1.0; vec2 warp = vec2(fbm(q*1.8), fbm(q*1.8+vec2(2.3,1.7))) - 0.5; xy += warp*0.35;
      float r = length(xy*vec2(0.8,1.0));
      float base = max(0.0, 1.0 - r);
      float n1 = fbm(xy*0.9 + vec2(0.0, t*0.18));
      float n2 = ridged(xy*1.25 + vec2(0.2, -t*0.15));
      float h = (base*1.25 + (0.55*n1 + 0.60*n2)*base);
      h = mix(h, terrace(h, 6.0, 1.6), 0.35);
      return h * uAmp;
    }

    float softShadow(vec2 pos, float h, vec3 Lm, float t){
      // project light to XY in model space
      vec2 dir = normalize(Lm.xy + vec2(1e-5));
      float step = 0.06; float res = 1.0; float k = 6.0;
      for(int i=1;i<=6;i++){
        float s = float(i)*step;
        float sampleH = heightAt(pos + dir*s, t);
        float expected = h + Lm.z*s; // climb along light direction
        float diff = sampleH - expected; // if neighbor higher than expected ‚Üí shadow
        res = min(res, 1.0 - clamp(diff*k, 0.0, 1.0));
      }
      return clamp(res, 0.0, 1.0);
    }

    void main(){
      vec3 N = normalize(vN);
      vec3 Lw = normalize(uLight);
      vec3 V = normalize(uCam - vWorld);
      vec3 up = vec3(0.0,1.0,0.0);

      // photometric terms
      float diff = max(dot(N,Lw), 0.0);

      // snow/ice mask by height & slope
      float heightMask = smoothstep(0.30, 0.75, vH);
      float slopeMask  = smoothstep(0.35, 0.80, max(0.0, dot(N, up)));
      float ice = clamp(0.55*heightMask + 0.45*slopeMask, 0.0, 1.0);

      vec3 rockCol = mix(vec3(0.09,0.13,0.20), vec3(0.12,0.22,0.30), clamp(vH*1.2,0.0,1.0));
      vec3 iceCol  = mix(uC1*0.60 + vec3(0.05,0.08,0.10), uC2*0.95, 0.65);

      // cheap specular only on ice
      vec3 H = normalize(Lw+V);
      float spec = pow(max(dot(N,H),0.0), 120.0) * ice * 0.9;

      // soft self shadow from heightfield
      float h = vH*uAmp; // current absolute height
      float shadow = softShadow(vXY, h, uLight, uTime*0.25);

      vec3 col = mix(rockCol, iceCol, ice);
      col = col * (0.28 + 0.78*diff*shadow) + spec * vec3(0.85,1.0,0.95);

      // base fog (denser unten)
      float dist = length(uCam - vWorld);
      float altitude = clamp(vH, 0.0, 1.0);
      float baseFog = mix(1.35, 1.0, altitude); // mehr Nebel unten
      float f = 1.0 - exp(-uFog * baseFog * dist*0.55);
      col = mix(col, vec3(0.06,0.08,0.12), clamp(f,0.0,1.0));

      gl_FragColor = vec4(col, 0.98);
    }`;

  const planeProgram = createProgram(createShader(gl.VERTEX_SHADER, planeVS), createShader(gl.FRAGMENT_SHADER, planeFS));
  const pLoc = {
    pos:gl.getAttribLocation(planeProgram,'aPos'),
    uv:gl.getAttribLocation(planeProgram,'aUv'),
    uTime:gl.getUniformLocation(planeProgram,'uTime'), uAmp:gl.getUniformLocation(planeProgram,'uAmp'), uFreq:gl.getUniformLocation(planeProgram,'uFreq'),
    uPV:gl.getUniformLocation(planeProgram,'uPV'), uModel:gl.getUniformLocation(planeProgram,'uModel'),
    uC1:gl.getUniformLocation(planeProgram,'uC1'), uC2:gl.getUniformLocation(planeProgram,'uC2'), uFog:gl.getUniformLocation(planeProgram,'uFog'), uCam:gl.getUniformLocation(planeProgram,'uCam'),
    uLight:gl.getUniformLocation(planeProgram,'uLight')
  };

  // Geometry grid (non-indexed)
  const segBase = (innerWidth<640)? 120:144; const w=6.0, h=3.5; const nx=segBase, ny=segBase;
  const verts=[], uvs=[];
  for(let y=0;y<ny;y++){
    for(let x=0;x<nx;x++){
      const x0 = x/nx - 0.5, x1 = (x+1)/nx - 0.5;
      const y0 = y/ny - 0.5, y1 = (y+1)/ny - 0.5;
      const p00=[x0*w, y0*h, 0], p10=[x1*w, y0*h, 0], p01=[x0*w, y1*h, 0], p11=[x1*w, y1*h, 0];
      const t00=[x0+0.5, y0+0.5], t10=[x1+0.5, y0+0.5], t01=[x0+0.5, y1+0.5], t11=[x1+0.5, y1+0.5];
      verts.push(...p00, ...p10, ...p11, ...p00, ...p11, ...p01);
      uvs.push(...t00, ...t10, ...t11, ...t00, ...t11, ...t01);
    }
  }
  function buf(type, data, usage){ const b = gl.createBuffer(); gl.bindBuffer(type, b); gl.bufferData(type, data, usage||gl.STATIC_DRAW); return b; }
  const planeVBO = buf(gl.ARRAY_BUFFER, new Float32Array(verts));
  const planeUVBO = buf(gl.ARRAY_BUFFER, new Float32Array(uvs));
  const planeCount = verts.length / 3;

  // ===== Crown Points (5 Sterne) + optional Shield =====
  const ptsVS = `
    precision mediump float; attribute vec3 aPos; uniform mat4 uPV; uniform mat4 uModel; uniform float uSize; varying float vIdx; void main(){
      gl_Position = uPV * uModel * vec4(aPos,1.0); gl_PointSize = uSize; }`;
  const ptsFS = `
    precision mediump float; uniform vec3 uCol; uniform float uPulse; void main(){
      vec2 d = gl_PointCoord - vec2(0.5); float r = length(d);
      float glow = smoothstep(0.5, 0.0, r) * (0.7 + 0.3*uPulse);
      gl_FragColor = vec4(uCol, glow);
    }`;
  const ptsProgram = createProgram(createShader(gl.VERTEX_SHADER, ptsVS), createShader(gl.FRAGMENT_SHADER, ptsFS));
  const ptLoc = { pos:gl.getAttribLocation(ptsProgram,'aPos'), uPV:gl.getUniformLocation(ptsProgram,'uPV'), uModel:gl.getUniformLocation(ptsProgram,'uModel'), uSize:gl.getUniformLocation(ptsProgram,'uSize'), uCol:gl.getUniformLocation(ptsProgram,'uCol'), uPulse:gl.getUniformLocation(ptsProgram,'uPulse') };

  const CROWN_N=6; const cData = new Float32Array(CROWN_N*3);
  function updateCrown(y){
    const R = 0.35, Z = 0.0;
    for(let i=0;i<5;i++){ const a = (i/5)*6.28318 + 0.2; cData[i*3+0] = Math.cos(a)*R; cData[i*3+1] = y; cData[i*3+2] = Math.sin(a)*R + Z; }
    cData[15] = 0.75; cData[16] = y*0.65; cData[17] = 0.6; // shield point
  }
  updateCrown(1.15);
  const ptsVBO = buf(gl.ARRAY_BUFFER, cData);

  // ===== Route (gl√ºhende Aufstiegs‚ÄëPunkte) =====
  const routeVS = `
    precision mediump float; attribute vec3 aPos; attribute float aIdx; varying float vIdx; uniform mat4 uPV; uniform mat4 uModel; uniform float uSize; void main(){ vIdx=aIdx; gl_Position = uPV * uModel * vec4(aPos,1.0); gl_PointSize = uSize; }`;
  const routeFS = `
    precision mediump float; varying float vIdx; uniform vec3 uCol; uniform float uTime; uniform float uGlow; void main(){ vec2 d=gl_PointCoord-vec2(0.5); float r=length(d); float core = smoothstep(0.48,0.0,r); float wave = 0.6 + 0.4*sin(uTime*2.0 - vIdx*8.0); float alpha = core * (0.35 + 0.65*uGlow*wave); gl_FragColor = vec4(uCol, alpha); }`;
  const routeProgram = createProgram(createShader(gl.VERTEX_SHADER, routeVS), createShader(gl.FRAGMENT_SHADER, routeFS));
  const rLoc = { pos:gl.getAttribLocation(routeProgram,'aPos'), idx:gl.getAttribLocation(routeProgram,'aIdx'), uPV:gl.getUniformLocation(routeProgram,'uPV'), uModel:gl.getUniformLocation(routeProgram,'uModel'), uSize:gl.getUniformLocation(routeProgram,'uSize'), uCol:gl.getUniformLocation(routeProgram,'uCol'), uTime:gl.getUniformLocation(routeProgram,'uTime'), uGlow:gl.getUniformLocation(routeProgram,'uGlow') };

  const ROUTE_COUNT = 180; const routeData = new Float32Array(ROUTE_COUNT*3); const routeIdx = new Float32Array(ROUTE_COUNT);
  for(let i=0;i<ROUTE_COUNT;i++){ routeIdx[i] = i/(ROUTE_COUNT-1); }
  const routeVBO = buf(gl.ARRAY_BUFFER, routeData); const routeIBO = buf(gl.ARRAY_BUFFER, routeIdx);

  // --- matrices
  const proj = mat4(), view = mat4(), pv = mat4(), model = mat4(); mat4Identity(model);
  // tilt plane (POSITIVE Winkel ‚Üí H√∂he zeigt nach oben, nicht kopf√ºber)
  const tilt = Math.PI/2.25; (function(){ const a=tilt, c=Math.cos(a), s=Math.sin(a); model.set([1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1]); })();

  const scene = { cam:[0,0.8,3.6], fog:0.20, crown:1.0, shield:0.0, routeGlow:1.0 };
  let target = JSON.parse(JSON.stringify(scene));

  function resize(){
    const hdr = document.querySelector('.hero'); const r = hdr.getBoundingClientRect();
    dpr = Math.min(devicePixelRatio||1, 1.75);
    canvas.width=r.width*dpr; canvas.height=r.height*dpr; canvas.style.width=r.width+'px'; canvas.style.height=r.height+'px';
    gl.viewport(0,0,canvas.width,canvas.height);
    mat4Perspective(proj, Math.PI/3.0, canvas.width/canvas.height, 0.1, 100.0);
  }
  window.addEventListener('resize', resize, {passive:true}); resize();

  // --- CPU‚ÄëNoise (entspricht Shader) f√ºr Route‚ÄëH√∂he
  const H = (function(){
    function fract(x){ return x-Math.floor(x); }
    function hash(x,y){ return fract(Math.sin(x*127.1 + y*311.7)*43758.5453123); }
    function noise(x,y){
      const xi=Math.floor(x), yi=Math.floor(y); const xf=x-xi, yf=y-yi;
      const a=hash(xi,yi), b=hash(xi+1,yi), c=hash(xi,yi+1), d=hash(xi+1,yi+1);
      const ux=xf*xf*(3-2*xf), uy=yf*yf*(3-2*yf);
      return (a*(1-ux)+b*ux) + (c-a)*uy*(1-ux) + (d-b)*ux*uy;
    }
    function fbm(x,y){ let v=0,a=0.5, m=[[1.6,1.2],[-1.2,1.6]]; for(let i=0;i<6;i++){ v+=a*noise(x,y); const nx=x*m[0][0]+y*m[0][1]; const ny=x*m[1][0]+y*m[1][1]; x=nx; y=ny; a*=0.5; } return v; }
    function ridged(x,y){ let v=0,a=0.5, m=[[1.7,1.1],[-1.1,1.7]]; for(let i=0;i<5;i++){ const n=1-Math.abs(2*noise(x,y)-1); v+=n*a; const nx=x*m[0][0]+y*m[0][1]; const ny=x*m[1][0]+y*m[1][1]; x=nx; y=ny; a*=0.5; } return v; }
    return function heightAt(x,y,t){ const r=Math.hypot(x*0.8, y*1.0); const base=Math.max(0,1-r); const n1=fbm(x*0.9, y*0.9 + t*0.20); const n2=ridged(x*1.2+0.2, y*1.2 - t*0.18); return (base*1.15 + (0.55*n1+0.45*n2)*base); };
  })();

  // pointer parallax
  let parX=0, parY=0; function onPointer(e){ const cx=(e.touches?e.touches[0].clientX:e.clientX)/innerWidth*2-1; const cy=(e.touches?e.touches[0].clientY:e.clientY)/innerHeight*2-1; parX=cx*0.5; parY=cy*0.2; heroGlow.style.setProperty('--x', (e.clientX||e.touches?.[0].clientX||0)+'px'); heroGlow.style.setProperty('--y', (e.clientY||e.touches?.[0].clientY||0)+'px'); }
  addEventListener('mousemove', onPointer, {passive:true}); addEventListener('touchmove', onPointer, {passive:true});

  gl.enable(gl.DEPTH_TEST); gl.clearColor(0.043,0.051,0.071,1);
  let t=0;
  // compute light in model space (rotate world light by -tilt around X)
  const lightWorld=[0.6,0.8,0.2];
  function rotX(v, ang){ const c=Math.cos(-ang), s=Math.sin(-ang); return [v[0], v[1]*c - v[2]*s, v[1]*s + v[2]*c]; }
  const lightModel = rotX(lightWorld, tilt);

  function drawMountain(){
    gl.useProgram(planeProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVBO); gl.enableVertexAttribArray(pLoc.pos); gl.vertexAttribPointer(pLoc.pos,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, planeUVBO); gl.enableVertexAttribArray(pLoc.uv); gl.vertexAttribPointer(pLoc.uv,2,gl.FLOAT,false,0,0);
    gl.uniform1f(pLoc.uTime, t);
    gl.uniform1f(pLoc.uAmp, 1.35); // higher relief for realism
    gl.uniform1f(pLoc.uFreq, 1.6);
    gl.uniform3f(pLoc.uC1, 0x8c/255, 0xf7/255, 0xe2/255);
    gl.uniform3f(pLoc.uC2, 0x7a/255, 0xa9/255, 0xff/255);
    gl.uniform1f(pLoc.uFog, scene.fog);
    gl.uniform3f(pLoc.uCam, scene.cam[0], scene.cam[1], scene.cam[2]);
    // light direction in model space (compute in JS)
    gl.uniform3f(pLoc.uLight, lightModel[0], lightModel[1], lightModel[2]);
    mat4LookAt(view, [scene.cam[0]+parX*0.6, scene.cam[1]+parY*0.3, scene.cam[2]], [0,0,0], [0,1,0]);
    mat4Mul(pv, proj, view);
    gl.uniformMatrix4fv(pLoc.uPV,false,pv);
    gl.uniformMatrix4fv(pLoc.uModel,false,model);
    gl.drawArrays(gl.TRIANGLES, 0, planeCount);
  }

  function drawCrown(){
    gl.disable(gl.DEPTH_TEST); gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(ptsProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, ptsVBO); gl.enableVertexAttribArray(ptLoc.pos); gl.vertexAttribPointer(ptLoc.pos,3,gl.FLOAT,false,0,0);
    gl.uniformMatrix4fv(ptLoc.uPV,false,pv); gl.uniformMatrix4fv(ptLoc.uModel,false,model);
    const pulse = 0.5 + 0.5*Math.sin(t*1.2);
    gl.uniform1f(ptLoc.uPulse, pulse);
    gl.uniform3f(ptLoc.uCol, 0.55, 0.95, 0.89);
    gl.uniform1f(ptLoc.uSize, (10.0 + 6.0*pulse) * dpr);
    gl.drawArrays(gl.POINTS, 0, 5);
    const shieldPulse = scene.shield * (0.5 + 0.5*Math.sin(t*3.0));
    gl.uniform3f(ptLoc.uCol, 0.55, 0.95, 0.89);
    gl.uniform1f(ptLoc.uSize, (40.0 + 30.0*shieldPulse) * dpr);
    gl.uniform1f(ptLoc.uPulse, 0.8);
    gl.drawArrays(gl.POINTS, 5, 1);
    gl.disable(gl.BLEND); gl.enable(gl.DEPTH_TEST);
  }

  function updateRoute(){
    // Spiral vom Rand zur Spitze; Y=H√∂he + Offset
    const turns = 4.8; const rStart = 2.0; const rEnd = 0.20; const yOff = 0.03;
    for(let i=0;i<ROUTE_COUNT;i++){
      const s = i/(ROUTE_COUNT-1);
      const r = rStart*(1-s) + rEnd*s;
      const ang = 0.6 + s*turns*6.28318;
      const x = Math.cos(ang)*r; const y = Math.sin(ang)*r;
      const h = H(x,y,t*0.25) * 1.25 + yOff; // gleiche Skalierung wie uAmp
      // Position im Modell‚ÄëSpace (vor uModel)
      routeData[i*3+0] = x*1.0; // unsere Plane nutzt direkt x/y in selben Einheiten
      routeData[i*3+1] = y* (3.5/6.0); // Angleichen an Seitenverh√§ltnis w/h
      routeData[i*3+2] = h;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, routeVBO); gl.bufferData(gl.ARRAY_BUFFER, routeData, gl.DYNAMIC_DRAW);
  }

  function drawRoute(){
    gl.disable(gl.DEPTH_TEST); gl.enable(gl.BLEND); gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.useProgram(routeProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, routeVBO); gl.enableVertexAttribArray(rLoc.pos); gl.vertexAttribPointer(rLoc.pos,3,gl.FLOAT,false,0,0);
    gl.bindBuffer(gl.ARRAY_BUFFER, routeIBO); gl.enableVertexAttribArray(rLoc.idx); gl.vertexAttribPointer(rLoc.idx,1,gl.FLOAT,false,0,0);
    gl.uniformMatrix4fv(rLoc.uPV,false,pv); gl.uniformMatrix4fv(rLoc.uModel,false,model);
    gl.uniform3f(rLoc.uCol, 0.55,0.95,0.89);
    gl.uniform1f(rLoc.uSize, 6.5*dpr);
    gl.uniform1f(rLoc.uTime, t);
    gl.uniform1f(rLoc.uGlow, scene.routeGlow);
    gl.drawArrays(gl.POINTS, 0, ROUTE_COUNT);
    gl.disable(gl.BLEND); gl.enable(gl.DEPTH_TEST);
  }

  function animate(){
    t += 0.016;
    for(let i=0;i<3;i++){ scene.cam[i] += (target.cam[i]-scene.cam[i])*0.05; }
    scene.fog += (target.fog - scene.fog)*0.05;
    scene.crown += (target.crown - scene.crown)*0.08;
    scene.shield += (target.shield - scene.shield)*0.10;
    scene.routeGlow += (target.routeGlow - scene.routeGlow)*0.08;

    mat4LookAt(view, [scene.cam[0]+parX*0.6, scene.cam[1]+parY*0.3, scene.cam[2]], [0,0,0], [0,1,0]);
    mat4Mul(pv, proj, view);

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    drawMountain();
    updateRoute();
    drawRoute();
    drawCrown();
    requestAnimationFrame(animate);
  }
  animate();

  // --- diagnostics (hash #debug)
  const dbg = document.getElementById('dbg');
  if(location.hash.includes('debug')){
    dbg.style.display='block';
    const info = gl.getExtension('WEBGL_debug_renderer_info');
    const ren = info? gl.getParameter(info.UNMASKED_RENDERER_WEBGL): 'n/a';
    const ven = info? gl.getParameter(info.UNMASKED_VENDOR_WEBGL): 'n/a';
    setInterval(()=>{ dbg.textContent = `dpr:${dpr.toFixed(2)}
size:${canvas.width}x${canvas.height}
fog:${scene.fog.toFixed(2)} route:${scene.routeGlow.toFixed(2)}
renderer:${ren}
vendor:${ven}`; }, 300);
  }

  // --- scene states per section (Kameraposen + Effekte)
  const states = {
    top:      { cam:[0,0.85,3.7], fog:0.22, crown:1.0, shield:0.0, routeGlow:0.6 },
    features: { cam:[0.65,0.95,3.25], fog:0.16, crown:1.0, shield:0.0, routeGlow:0.9 },
    how:      { cam:[-0.55,1.05,3.05], fog:0.12, crown:1.05, shield:1.0, routeGlow:1.2 },
    pricing:  { cam:[0,1.1,3.9], fog:0.08, crown:1.1, shield:0.0, routeGlow:0.5 }
  };
  function setState(id){ if(states[id]){ target = JSON.parse(JSON.stringify(states[id])); } }

  // smooth anchor scroll + scene state
  const nav = document.querySelector('.nav');
  document.querySelectorAll('a[href^="#"]').forEach(a=>{
    a.addEventListener('click', function(e){
      const id = this.getAttribute('href'); if(!id || id==='#') return; const el = document.querySelector(id); if(!el) return;
      e.preventDefault(); const name = id.replace('#',''); setState(name);
      const top = el.getBoundingClientRect().top + window.scrollY - (nav?.offsetHeight||72) - 8; window.scrollTo({top, behavior:'smooth'});
    });
  });
})();

// ======================= Scroll Reveal (ohne GSAP) =======================
(function(){
  const els = document.querySelectorAll('[data-reveal]');
  if(!('IntersectionObserver' in window)) { els.forEach(el=>el.classList.add('revealed')); return; }
  const io = new IntersectionObserver((entries)=>{
    entries.forEach(e=>{ if(e.isIntersecting){ e.target.classList.add('revealed'); io.unobserve(e.target);} });
  }, {threshold:0.1});
  els.forEach(el=>io.observe(el));
  const y = document.getElementById('year'); if(y){ y.textContent = new Date().getFullYear(); }
})();
</script>
</body>
</html>
